# Улучшение качества распознавания номеров

Этот документ описывает методы улучшения распознавания номеров в плохом качестве.

## ⚠️ ВАЖНО: Предобработка может ухудшить результаты!

Тестирование показало, что **предобработка изображений (CLAHE, denoise, sharpen) часто ухудшает качество распознавания** на нормальных фотографиях. Используйте её только для специфических случаев с очень плохим контрастом/шумом.

## Методы улучшения в recognize_test.py

### 1. Предобработка изображений (Image Preprocessing)

**ОТКЛЮЧЕНО по умолчанию**. Может применяться для очень низкокачественных изображений:

#### CLAHE (Contrast Limited Adaptive Histogram Equalization)
```python
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
enhanced = clahe.apply(gray)
```
- **Назначение**: Улучшает контраст в локальных областях изображения
- **Эффект**: Делает текст на номере более читаемым при плохом освещении
- **Параметры**:
  - `clipLimit=2.0` - ограничение усиления контраста (предотвращает шум)
  - `tileGridSize=(8, 8)` - размер блоков для адаптивной обработки

#### Шумоподавление (Denoising)
```python
denoised = cv2.fastNlMeansDenoising(enhanced, None, h=10,
                                    templateWindowSize=7,
                                    searchWindowSize=21)
```
- **Назначение**: Удаляет цифровой шум с изображения
- **Эффект**: Уменьшает артефакты сжатия JPEG, зернистость
- **Параметры**:
  - `h=10` - сила шумоподавления
  - `templateWindowSize=7` - размер окна для сравнения пикселей
  - `searchWindowSize=21` - размер области поиска похожих блоков

#### Повышение резкости (Sharpening)
```python
kernel = np.array([[-1, -1, -1],
                   [-1,  9, -1],
                   [-1, -1, -1]])
sharpened = cv2.filter2D(denoised, -1, kernel)
```
- **Назначение**: Делает края символов более четкими
- **Эффект**: Улучшает читаемость размытых символов
- **Метод**: Использует свёрточное ядро для усиления краев

### 2. AI Upscaling (HAT - Hybrid Attention Transformer)

**ВСТРОЕНО в Nomeroff-Net 4.0**. Требует установки дополнительной библиотеки:

```bash
pip install git+https://github.com/ria-com/upscaler.git
```

**Как работает:**
- Автоматически применяется **ТОЛЬКО** для номеров высотой **< 50 пикселей**
- Увеличивает разрешение в **4 раза** используя нейросеть HAT
- Включается параметром `upscaling=True` в pipeline
- Не требует дополнительной настройки

**⚠️ КРИТИЧНЫЕ ПРЕДУПРЕЖДЕНИЯ:**
- **НЕ РАБОТАЕТ на CPU!** Вызывает ошибку: `ValueError: not enough values to unpack (expected 2, got 0)`
- **Требует GPU (CUDA)** для работы
- Даже на GPU работает медленно (~5-10 сек на изображение)

**Пример использования (ТОЛЬКО с GPU!):**
```python
from nomeroff_net import pipeline
import os

# ВАЖНО: Убедитесь, что используется GPU
os.environ["CUDA_VISIBLE_DEVICES"] = "0"  # Используйте GPU

# Включить upscaling для маленьких номеров
number_plate_detection_and_reading = pipeline(
    "number_plate_detection_and_reading",
    image_loader="opencv",
    upscaling=True  # Автоматически увеличит номера < 50px (ТОЛЬКО с GPU!)
)
```

**Для CPU:**
Если у вас нет GPU, upscaling **недоступен**. Для распознавания маленьких номеров:
1. Используйте камеры с более высоким разрешением
2. Располагайте камеры ближе к номерам
3. Используйте внешние инструменты upscaling перед обработкой (Real-ESRGAN, waifu2x)

### 3. Понижение порога детекции

```python
MIN_DETECTION_CONFIDENCE = 0.4  # По умолчанию: 0.4
```

- **Назначение**: Контролирует минимальную уверенность детектора для обнаружения номера
- **Эффект**: Понижение находит больше номеров, но увеличивает false positives
- **Рекомендация**:
  - `0.4-0.5` - для нормального качества (рекомендуется)
  - `0.25-0.35` - для плохого качества (больше ложных срабатываний)
  - `0.6+` - для high precision (может пропускать некоторые номера)

## Конфигурация скрипта

В файле [recognize_test.py](recognize_test.py:57-73) можно настроить:

```python
USE_PREPROCESSING = False           # Предобработка изображений (ОТКЛЮЧЕНО)
MIN_DETECTION_CONFIDENCE = 0.4      # Порог уверенности детекции
USE_UPSCALING = False               # AI upscaling (ОТКЛЮЧЕНО)
```

## Результаты тестирования

На тестовых изображениях из `data/examples/test/` (с отключенной предобработкой):
- **Обработано изображений**: 2
- **Найдено номеров**: 1-2 (зависит от качества)
- **Средняя точность на найденных**: 100%

### Примеры результатов:

**Изображение 1** (0a4cf1ab47d219cc61225f599a6427f9.jpg):
- ✅ Номер `K206TC123`: Confidence 100% (регион: ru) - ВЕРНО
- ⚠️ Ложное срабатывание: `1206ТСМ` - детектор находит лишний "номер"

**Изображение 2** (0a6c9609d3ecb0e24ad66296716d1412.jpg):
- ❌ Номер `МВ789123` не найден - слишком низкое качество (~30px высотой, сильное сжатие)
- Требуется upscaling на GPU для распознавания

### Выводы:
- **Предобработка ухудшает результаты** на нормальных фото
- Детектор хорошо работает на номерах >50px высотой
- Номера <40px требуют GPU и upscaling
- Возможны ложные срабатывания на текстурах/тексте

## Дополнительные рекомендации для улучшения качества

### 1. Качество исходных изображений (КРИТИЧНО!)

**Минимальные требования:**
- Высота номера: **не менее 50 пикселей**
- Разрешение: 150x45px минимум
- Рекомендуемое: 200x60px или выше
- Формат: JPEG (качество 85+) или PNG
- Избегать сильного сжатия JPEG

**Номера <40px высотой:**
- Практически не распознаются без GPU и upscaling
- Требуют специальной обработки
- Могут не распознаваться вообще

### 2. Условия съёмки

**Обязательно:**
- ✅ Хорошее освещение
- ✅ Номер в фокусе (не размыт)
- ✅ Прямой угол съёмки (±30° максимум)
- ✅ Номер чистый, читаемый

**Избегать:**
- ❌ Сильные тени на номере
- ❌ Блики и отражения
- ❌ Размытие от движения
- ❌ Грязь, снег на номере

### 3. Настройка детектора

Можно изменить параметры детектора в коде:

```python
# В nomeroff_net/pipes/number_plate_localizators/yolo_kp_detector.py
def predict(self, imgs, min_accuracy=0.4):
    model_outputs = self.model(imgs,
                               conf=min_accuracy,  # Порог уверенности
                               iou=0.7,            # IoU для NMS
                               agnostic_nms=True)  # Класс-агностичный NMS
```

### 4. Использование разных image loaders

```python
# OpenCV (по умолчанию)
pipeline("number_plate_detection_and_reading", image_loader="opencv")

# TurboJPEG (быстрее для больших JPEG)
pipeline("number_plate_detection_and_reading", image_loader="turbo")

# Pillow
pipeline("number_plate_detection_and_reading", image_loader="pillow")
```

### 5. Batch processing для производительности

```python
# Обрабатывать несколько изображений за раз
result = pipeline(image_list, batch_size=4, num_workers=2)
```

## Ограничения и проблемы

### 1. Предобработка изображений
**Проблема**: Часто **УХУДШАЕТ** результаты на нормальных фотографиях

**Пример**: Номер распознается как "34208ТСЦ" вместо "К206ТС123"

**Решение**: Отключить `USE_PREPROCESSING = False` (по умолчанию отключено)

### 2. AI Upscaling - НЕ РАБОТАЕТ на CPU!
**Проблема**: Встроенный upscaling (HAT) **НЕ РАБОТАЕТ на CPU**

**Ошибка**: `ValueError: not enough values to unpack (expected 2, got 0)`

**Причина**: Библиотека upscaler требует GPU (CUDA) для работы

**Решение для CPU**:
- Отключить `USE_UPSCALING = False` (по умолчанию отключено)
- Использовать внешние инструменты upscaling перед обработкой:
  - **Real-ESRGAN**: `pip install realesrgan` (лучшее качество)
  - **waifu2x**: онлайн или локально
  - **Upscayl**: GUI приложение для upscaling изображений

**Решение для GPU**:
- Установить CUDA и cuDNN
- Включить `USE_UPSCALING = True`
- Убедиться что `CUDA_VISIBLE_DEVICES` указывает на GPU

**⚠️ ВАЖНО для RTX 5070 Ti (sm_120/Blackwell):**
RTX 5070 Ti **НЕ ПОДДЕРЖИВАЕТСЯ** текущими версиями PyTorch (включая nightly 2.11.0.dev20260113)!

**Проблема:**
- Compute Capability sm_120 не скомпилирована в доступных бинарных сборках PyTorch
- PyTorch 2.11.0.dev (nightly с CUDA 12.6) поддерживает только sm_50, sm_60, sm_70, sm_75, sm_80, sm_86, sm_90
- GPU определяется, но операции вызывают предупреждение о несовместимости
- Для sm_120 нужна сборка PyTorch с CUDA 12.8 или 13.0 (пока недоступна)

**Решения:**
1. **Ждать официальную версию** PyTorch с поддержкой sm_120 (рекомендуется) - следить за https://pytorch.org/
2. **Компилировать из исходников** с CUDA 12.8/13.0 (~2-4 часа): https://github.com/pytorch/pytorch#from-source
3. **Использовать CPU** (текущий вариант) - работает, но медленно и без upscaling

**Проверка поддержки:**
```bash
python -c "import torch; print(f'PyTorch: {torch.__version__}'); print(f'GPU: {torch.cuda.get_device_name(0) if torch.cuda.is_available() else \"N/A\"}'); print(f'CC: {torch.cuda.get_device_capability(0) if torch.cuda.is_available() else \"N/A\"}')"
```

**Текущий статус (январь 2026):**
- ✅ GPU определяется: NVIDIA GeForce RTX 5070 Ti
- ✅ Compute capability: (12, 0)
- ❌ PyTorch binaries не содержат sm_120 kernels
- ❌ Upscaling недоступен без GPU поддержки

### 3. Очень маленькие номера (<40px)
**Проблема**: Практически не распознаются на CPU

**Решение**:
- Использовать камеры с высоким разрешением
- Располагать камеры ближе к номерам
- Использовать GPU + upscaling (если доступно)

### 4. Ложные срабатывания (False Positives)
**Проблема**: Детектор находит "номера" на текстурах, тексте, решётках радиатора

**Решение**:
- Повысить порог: `MIN_DETECTION_CONFIDENCE = 0.5-0.6`
- Фильтровать результаты по confidence score
- Проверять формат номера регулярными выражениями

## Альтернативные подходы

### Для очень низкого качества:

1. **Многоэтапная обработка**:
   - Применить несколько вариантов предобработки
   - Выбрать результат с наивысшей уверенностью

2. **Ансамбль моделей**:
   - Использовать несколько моделей OCR
   - Объединить результаты голосованием

3. **Внешние upscaling инструменты**:
   - Real-ESRGAN
   - GFPGAN
   - SwinIR

## Пример использования

```bash
# Запуск с настройками по умолчанию
python recognize_test.py

# Изображения должны быть в data/examples/test/
# Результаты выводятся в консоль
# Временные enhanced изображения удаляются автоматически
```

## Мониторинг качества

Скрипт показывает confidence score для каждого символа:
- **> 0.95**: Отличное качество распознавания
- **0.85-0.95**: Хорошее качество
- **0.70-0.85**: Удовлетворительное качество
- **< 0.70**: Требует проверки

## Поддержка

Для сообщения о проблемах: https://github.com/ria-com/nomeroff-net/issues
